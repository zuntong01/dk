# Generated by CONFIG REWRITE
sentinel known-replica mymaster 172.18.0.6 6379
sentinel known-replica mymaster 172.18.0.8 6379
sentinel known-replica mymaster 172.18.0.7 6379
sentinel known-replica mymaster 172.18.0.3 6379
sentinel known-replica mymaster 172.18.0.9 6379
sentinel known-sentinel mymaster 172.18.0.5 26379 bcf60b6df6cd0ef52886b96b8ac9d16e83fae82e
sentinel known-sentinel mymaster 172.18.0.7 26379 d343dfb92de68b94af9667b3aff01552768e060c
sentinel known-sentinel mymaster 172.18.0.9 26379 4f68abe60db2269774e3b38f0ffd8c2fc77f1cac
sentinel current-epoch 367

### QA #1
# cat redis-data-cache.properties
#-- Redis data-cache configuration
#- redis hosts ex: 127.0.0.1:6379, 127.0.0.2:6379, 127.0.0.2:6380, ....
redis.hosts=qa-was1-nep-sal.lge.com:9981, qa-was2-nep-sal.lge.com:9981, qa-redis1-nep.lge.com:16379, qa-redis2-nep.lge.com:16379
#- redis password (for stand-alone mode)
redis.password=dlatl00
#- set true to enable redis cluster mode
redis.cluster.enabled=false

# application.xml
spring:
  profiles: dev
  redis:
    lettuce:
      port: 9981
      host: dev-was1-nep-sal.lge.com
      password: '!dlatl00'
      pool:
        max-active: 10  # pool에 할당 가능한 최대 커넥션 수(음수는 무한)
        max-idle: 10
        min-idle: 2
    cache:
      port: 7577
      host: dev-was1-nep-cmn.lge.com
      password: '!dlatl00'
  session:
    store-type: redis
    redis:
      flush-mode: ON_SAVE

spring:
  profiles: dev
  redis:
    password: 'dlatl00'
    master:
      host: qa-was1-nep-sal.lge.com
      port: 9981
    slaves:
      - host: qa-was2-nep-sal.lge.com
        port: 9981
    sentinel:
      master: 'mymaster'
      nodes: qa-was1-nep-sal.lge.com,qa-was2-nep-sal.lge.com
      password: 'dlatl00'
      port: 26379
  cache:
    password: 'dlatl00'
    master:
      host: qa-redis1-nep.lge.com
      port: 16379
    slaves:
      - host: qa-redis2-nep.lge.com
        port: 16379
    sentinel:
      master: 'mymaster'
      nodes: qa-redis1-nep.lge.com,qa-redis2-nep.lge.com
      password: 'dlatl00'
      port: 26379
  session:
    store-type: redis
    redis:
      flush-mode: on-save

# redis.conf
bind 0.0.0.0
protected-mode yes
port 9981

tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize no
pidfile "/var/run/redis_9981.pid"
loglevel notice
logfile "/engn001/redis/logs/redis_9981.log"

databases 16
always-show-logo no
set-proc-title yes
proc-title-template "{title} {listen-addr} {server-mode}"
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes

dbfilename "dump.rdb"
rdb-del-sync-files no
dir "/engn001/redis"
masterauth "dlatl00"

replica-serve-stale-data yes
replica-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-diskless-load disabled
repl-ping-replica-period 10
repl-timeout 60
repl-disable-tcp-nodelay no
replica-priority 100

acllog-max-len 128
requirepass "dlatl00"

lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

lazyfree-lazy-user-del no
lazyfree-lazy-user-flush no
oom-score-adj no
oom-score-adj-values 0 200 800
disable-thp yes
appendonly yes
appendfilename "appendonly_6379.aof"
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
aof-use-rdb-preamble yes
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events ""
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000

stream-node-max-bytes 4kb
stream-node-max-entries 100
activerehashing yes

client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

hz 10
dynamic-hz yes
aof-rewrite-incremental-fsync yes
rdb-save-incremental-fsync yes

jemalloc-bg-thread yes
save 3600 1
save 300 100
save 60 10000

replicaof 10.185.176.139 9981

# sentinel.conf
bind 0.0.0.0
port 26379
daemonize no
pidfile "/var/run/redis-sentinel.pid"
logfile ""
dir "/tmp"

sentinel monitor mymaster 10.185.176.139 9981 1
sentinel auth-pass mymaster dlatl00
sentinel down-after-milliseconds mymaster 5000

acllog-max-len 128

sentinel deny-scripts-reconfig yes
sentinel resolve-hostnames no

sentinel announce-hostnames no
protected-mode no
user default on nopass ~* &* +@all
sentinel myid 0c42f714d5c93c754f979b6a6215cc209f178097
sentinel config-epoch mymaster 28
sentinel leader-epoch mymaster 20586
sentinel current-epoch 20587
sentinel known-sentinel mymaster 10.185.176.165 0 55f8c49a649873010f35e06bc73d41458b03c11f
sentinel known-replica mymaster 10.185.176.116 9981
sentinel known-sentinel mymaster 10.185.176.165 0 7be0a0f937ac29368e7f8c9aba9dd8ffc90d61b5
sentinel known-sentinel mymaster 10.185.176.165 0 1081f579b175b0a224f5a92f6ad1ec38f993235f
sentinel known-replica mymaster 10.185.176.140 9981
sentinel known-replica mymaster 10.185.176.165 9981
sentinel known-replica mymaster 10.185.176.115 9981
sentinel known-replica mymaster 10.185.176.92 9981
sentinel known-replica mymaster 10.185.176.93 9981
sentinel known-replica mymaster 10.185.176.166 9981
sentinel known-sentinel mymaster 10.185.176.165 0 af52a495b1a81aae38ff2db80741f98710174784
sentinel known-sentinel mymaster 10.185.176.139 26379 67f0ffc39821931b5594e9ce3d1df2fdc7002519
sentinel known-sentinel mymaster 127.0.0.1 26379 0c42f714d5c93c754f979b6a6215cc209f178097
sentinel known-sentinel mymaster 10.185.176.165 0 04501b8868c9b2296c370c969323e748fe6ff614
sentinel known-sentinel mymaster 10.185.176.165 0 56febba2557815bd8c411d556edf25bfdfe7b08d
sentinel known-sentinel mymaster 127.0.0.1 26379 0b7715374bc18cae085a562f964da66261a5aff2
sentinel known-sentinel mymaster 10.185.176.165 26379 0da1f838e0d46da78a6346163a40dc6fb9e77794


## recli -p 26379
> info sentnel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=10.185.176.139:9981,slaves=7,sentinels=11

./redis-cli -p 26379
127.0.0.1:26379> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=odown,address=10.185.176.92:9981,slaves=0,sentinels=1



###################################################################################

1. Config.java
    public static final String APPLICATION_PROPERTIES_FILE = "redis-data-cache.properties";

    @Property(name = "redis.hosts", defaultValue = "127.0.0.1:6379")
    private String redisHosts;

    @Property(name = "redis.sentinel.enabled", type = BOOLEAN, defaultValue = "false")
    private Boolean redisSentinelEnabled;

    @Property(name = "redis.sentinel.master", defaultValue = "mymaster")
    private String redisSentinelMaster;

 @Override
    public String toString() {
        return "Config{" +
                "redisHosts='" + redisHosts + '\'' +
                ", redisSentinelEnabled=" + redisSentinelEnabled +
                ", redisSentinelMaster='" + redisSentinelMaster + '\'' +
                '}';
    }
    /** To get redis config type. */
    public RedisConfigType getRedisConfigType() {
        if (this.getRedisClusterEnabled()) {
            return RedisConfigType.CLUSTER;
        } else if (this.getRedisSentinelEnabled()) {
            return RedisConfigType.SENTINEL;
        }
        return RedisConfigType.DEFAULT;
    }
}
############################################################################################################3
2. RedisCache.java
## getJedisNodes에서 redis.host로 주소:포트를 1개씩 잘라서 nodes 에 넣는다.
## JedisPoolConfig 에서 그밖에 연결설정정보를 받아와 poolConfig에 넣는다.
## getRedisConfigType 이 SETINEL일 경우 RedisSentinellManager를 호출하여 실행함

    private void initialize(Config config) {
        Collection<?> nodes = getJedisNodes(config.getRedisHosts(), config.getRedisConfigType());
        JedisPoolConfig poolConfig = getPoolConfig(config);
        switch (config.getRedisConfigType()) {
            case CLUSTER:
                this.dataCache = new RedisClusterManager((Set<HostAndPort>) nodes,
                        config.getRedisPassword(),
                        config.getRedisTimeout(),
                        poolConfig);
                break;
            case SENTINEL:
                this.dataCache = new RedisSentinelManager((Set<String>) nodes,
                        config.getRedisSentinelMaster(),
                        config.getRedisPassword(),
                        config.getRedisDatabase(),
                        config.getRedisTimeout(),
                        poolConfig);
                break;
            default:
                this.dataCache = new RedisStandardManager(((List<String>) nodes).get(0),
                        Integer.parseInt(((List<String>) nodes).get(1)),
                        config.getRedisPassword(),
                        config.getRedisDatabase(),
                        config.getRedisTimeout(),
                        poolConfig);
                break;


    private Collection<?> getJedisNodes(String hosts, RedisConfigType configType) {
        hosts = hosts.replaceAll("\\s", "");
        String[] hostPorts = hosts.split(",");

        Set<Object> nodes = null;

        for (String hostPort : hostPorts) {
            String[] hostPortArr = hostPort.split(":");

            switch (configType) {
                case CLUSTER:
                    nodes = (nodes == null) ? new HashSet<>() : nodes;
                    nodes.add(new HostAndPort(hostPortArr[0], Integer.parseInt(hostPortArr[1])));
                    break;
                case SENTINEL:
                    nodes = (nodes == null) ? new HashSet<>() : nodes;
                    nodes.add(new HostAndPort(hostPortArr[0], Integer.parseInt(hostPortArr[1])).toString());
                    break;
                default:
                    int port = Integer.parseInt(hostPortArr[1]);
                    if (!hostPortArr[0].isEmpty() && port > 0) {
                        List<String> node = new ArrayList<>();
                        node.add(hostPortArr[0]);
                        node.add(String.valueOf(port));
                        return node;
                    }
            }
        }
        return nodes;

############################################################################################################
3. RedisSentinelManager.java
## RedisSentinelManater라는 클래스가 위에 인자값을 받아와서, JedisSentienlPool 을 호출함

class RedisSentinelManager extends RedisManager {

    private static final long FAILURE_WAIT_TIME = 2000L;

    RedisSentinelManager(Set<String> nodes,
                         String masterName,
                         String password,
                         int database,
                         int timeout,
                         JedisPoolConfig poolConfig) {
        super(new JedisSentinelPool(masterName, nodes, poolConfig, timeout, password, database), FAILURE_WAIT_TIME);
    }
}
############################################################################################################ㅁ
※ jedis.jar 파일에 있는 메소드들임

4. JedisSentinelPool.java
## new Jedis 에서 전달받은 노드정보로 연결생성함
## jedis.sentinelGetMasterAddrByName : 연결된 노드에서 master의 접속주소가 무엇인지 확인함


  private HostAndPort initSentinels(Set<HostAndPort> sentinels, final String masterName) {

    HostAndPort master = null;
    boolean sentinelAvailable = false;

    log.info("Trying to find master from available Sentinels...");

    for (HostAndPort sentinel : sentinels) {

      log.debug("Connecting to Sentinel {}", sentinel);

      try (Jedis jedis = new Jedis(sentinel, sentinelClientConfig)) {

        List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);
        // connected to sentinel...
        sentinelAvailable = true;

        if (masterAddr == null || masterAddr.size() != 2) {
          log.warn("Can not get master addr, master name: {}. Sentinel: {}", masterName, sentinel);
          continue;
        }

        master = toHostAndPort(masterAddr);
        log.debug("Found Redis master at {}", master);
        break;
      } catch (JedisException e) {
        // resolves #1036, it should handle JedisException there's another chance
        // of raising JedisDataException
        log.warn(
            "Cannot get master address from sentinel running @ {}. Reason: {}. Trying next one.",
            sentinel, e);
      }
    }

    if (master == null) {
      if (sentinelAvailable) {
        // can connect to sentinel, but master name seems to not monitored
        throw new JedisException("Can connect to sentinel, but " + masterName
            + " seems to be not monitored...");
      } else {
        throw new JedisConnectionException("All sentinels down, cannot determine where is "
            + masterName + " master is running...");
      }
    }

    log.info("Redis master running at {}, starting Sentinel listeners...", master);

    for (HostAndPort sentinel : sentinels) {

      MasterListener masterListener = new MasterListener(masterName, sentinel.getHost(), sentinel.getPort());
      // whether MasterListener threads are alive or not, process can be stopped
      masterListener.setDaemon(true);
      masterListeners.add(masterListener);
      masterListener.start();
    }

    return master;
  }

############################################################################################################
※ jedis.jar 파일에 있는 메소드들임

5. Jedis.java
## sentinelGetMasterAddrByName 에서 Redis 클라이언트(client)를 사용하여 Sentinel에게 SENTINEL GET-MASTER-ADDR-BY-NAME mymaster 명령을 실행해 현재 master노드의 정보를 받아옴

 @Override
  public List<String> sentinelGetMasterAddrByName(final String masterName) {
    client.sentinel(Protocol.SENTINEL_GET_MASTER_ADDR_BY_NAME, masterName);
    final List<Object> reply = client.getObjectMultiBulkReply();
    return BuilderFactory.STRING_LIST.build(reply);
  }
############################################################################################################
※ jedis.jar 파일에 있는 메소드들임
6. Client.java
## client 생성하는 BinaryClient 도 가져옴..
## Client.java에서 sentinel을 실행함
## sentinel은 다시 setinel을 실행함 해당 sentinel은 BinaryClient.java에 좀재함

@Deprecated
public class Client extends BinaryClient implements Commands {

  public Client() {
    super();
  }

  public void sentinel(final String... args) {
    sentinel(SafeEncoder.encodeMany(args));
  }

  public void sentinel(SentinelKeyword subcommand, final String... args) {
    sentinel(subcommand, SafeEncoder.encodeMany(args));
  }
############################################################################################################

※ jedis.jar 파일에 있는 메소드들임
7. BinaryClient.java .java


  public void sentinel(final byte[]... args) {
    sendCommand(SENTINEL, args);
  }

  public void sentinel(SentinelKeyword subcommand, final byte[]... args) {
    sendCommand(SENTINEL, joinParameters(subcommand.getRaw(), args));
  }

  public void sentinel(SentinelKeyword subcommand) {
    sendCommand(SENTINEL, subcommand.getRaw());


※ jedis.jar 파일에 있는 메소드들임
8. Protocol.java

  @Deprecated public static final String SENTINEL_GET_MASTER_ADDR_BY_NAME = "get-master-addr-by-name";

############################################################################################################




